import { NodePgDatabase } from 'drizzle-orm/node-postgres';
import { invoices } from '../schema/invoices';
import { invoiceItems } from '../schema/invoice-items';
import { packages } from '../schema/packages';
import { companies } from '../schema/companies';
import { and, eq, ne } from 'drizzle-orm';
import logger from '../../utils/logger';

/**
 * Seed invoices and invoice items tables with initial data
 */
export async function seedInvoices(db: NodePgDatabase<any>) {
  try {
    logger.info('Seeding invoices and invoice items...');
    
    // Check if invoices already exist to avoid duplicates
    const existingInvoices = await db.select().from(invoices);
    
    if (existingInvoices.length > 0) {
      logger.info(`Found ${existingInvoices.length} existing invoices, skipping seed`);
      return;
    }
    
    // Get companies
    const companyRecords = await db.select({
      id: companies.id,
    }).from(companies);
    
    // For each company
    for (const company of companyRecords) {
      // Get packages that are processed or ready_for_pickup (eligible for invoicing)
      const packageRecords = await db.select({
        id: packages.id,
        userId: packages.userId,
        weight: packages.weight,
        declaredValue: packages.declaredValue,
      })
      .from(packages)
      .where(
        and(
          eq(packages.companyId, company.id),
          ne(packages.status, 'pre_alert') // Skip packages that are still pre-alerts
        )
      );
      
      // Group packages by user for invoicing
      const packagesByUser = {};
      packageRecords.forEach(pkg => {
        if (!packagesByUser[pkg.userId]) {
          packagesByUser[pkg.userId] = [];
        }
        packagesByUser[pkg.userId].push(pkg);
      });
      
      // Create invoices for each user with packages
      for (const [userId, userPackages] of Object.entries(packagesByUser)) {
        if (userPackages.length === 0) continue;
        
        // Calculate invoice totals
        let subtotal = 0;
        const taxRate = 0.15; // 15% tax
        
        // Create invoice
        const invoiceNumber = `INV-${company.id.substring(0, 4)}-${Math.floor(Math.random() * 10000)}`;
        
        // Issue date (0-7 days ago)
        const issueDate = new Date();
        issueDate.setDate(issueDate.getDate() - Math.floor(Math.random() * 8));
        
        // Due date (7-14 days after issue date)
        const dueDate = new Date(issueDate);
        dueDate.setDate(dueDate.getDate() + 7 + Math.floor(Math.random() * 8));
        
        // Invoice statuses weighted toward 'issued' and 'paid'
        const statusOptions = ['draft', 'issued', 'paid', 'issued', 'paid', 'overdue'];
        const randomStatus = statusOptions[Math.floor(Math.random() * statusOptions.length)];
        
        // Insert the invoice first to get its ID
        const [invoiceResult] = await db.insert(invoices).values({
          companyId: company.id,
          userId: userId,
          invoiceNumber: invoiceNumber,
          status: randomStatus,
          issueDate: issueDate.toISOString(),
          dueDate: dueDate.toISOString(),
          subtotal: 0, // Will update after adding items
          taxAmount: 0, // Will update after adding items
          totalAmount: 0, // Will update after adding items
          notes: 'Sample invoice generated by seed script',
        }).returning({ id: invoices.id });
        
        // Add invoice items for each package
        for (const pkg of userPackages) {
          // Shipping fee based on weight
          const shippingFee = Math.max(15, pkg.weight * 2.5);
          subtotal += shippingFee;
          
          await db.insert(invoiceItems).values({
            companyId: company.id,
            invoiceId: invoiceResult.id,
            packageId: pkg.id,
            description: `Shipping fee for package (${pkg.weight} lbs)`,
            quantity: 1,
            unitPrice: shippingFee,
            lineTotal: shippingFee,
            type: 'shipping',
          });
          
          // Handling fee (flat rate)
          const handlingFee = 5;
          subtotal += handlingFee;
          
          await db.insert(invoiceItems).values({
            companyId: company.id,
            invoiceId: invoiceResult.id,
            packageId: pkg.id,
            description: 'Package handling fee',
            quantity: 1,
            unitPrice: handlingFee,
            lineTotal: handlingFee,
            type: 'handling',
          });
          
          // Customs fee (percentage of declared value)
          const customsFee = Math.max(10, pkg.declaredValue * 0.15);
          subtotal += customsFee;
          
          await db.insert(invoiceItems).values({
            companyId: company.id,
            invoiceId: invoiceResult.id,
            packageId: pkg.id,
            description: `Customs processing (${pkg.declaredValue} declared value)`,
            quantity: 1,
            unitPrice: customsFee,
            lineTotal: customsFee,
            type: 'customs',
          });
        }
        
        // Calculate tax
        const taxAmount = subtotal * taxRate;
        const totalAmount = subtotal + taxAmount;
        
        // Update the invoice with the final totals
        await db.update(invoices)
          .set({
            subtotal: subtotal,
            taxAmount: taxAmount,
            totalAmount: totalAmount,
          })
          .where(eq(invoices.id, invoiceResult.id));
      }
    }
    
    logger.info('Invoices and invoice items seeded successfully');
  } catch (error) {
    logger.error(error, 'Error seeding invoices');
    throw error;
  }
} 